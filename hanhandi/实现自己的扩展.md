

# TEN 框架扩展开发入门指南

作为初学者，以下是在 TEN 框架中开发和运行自己的扩展的分步指南。我将分别介绍 Python、Go 和 C++ 扩展的开发流程。

## 前提条件

1. 已安装 Docker 和 Docker Compose
2. 已克隆 TEN Agent 仓库并设置好环境
3. 基本了解你选择的编程语言（Python、Go 或 C++）

## 第一步：设置开发环境

```bash
# 克隆仓库
git clone https://github.com/TEN-framework/ten-agent.git
cd ten-agent

# 创建并配置.env文件
cp ./.env.example ./.env
# 编辑.env文件，设置Agora App ID和App Certificate

# 启动开发容器
docker compose up -d

# 进入容器
docker exec -it ten_agent_dev bash
```
## 第二步：学习 TEN 框架
了解 TEN 框架中扩展调用哪些 API 主要通过以下几个来源：

### 1. 现有扩展的源代码

最直接的参考来源是查看现有扩展的源代码，特别是：

- `/app/agents/ten_packages/extension/` 目录下的各种扩展实现
- 例如 `openai_chatgpt_python`、`qwen_llm_python` 等扩展的实现代码

这些代码展示了如何使用框架提供的 API 来实现各种功能。

### 2. 扩展的 manifest.json 文件

每个扩展的 `manifest.json` 文件定义了该扩展的 API 接口，包括：

- 输入/输出数据类型 (`data_in`/`data_out`)
- 支持的命令 (`cmd_in`/`cmd_out`)
- 配置属性 (`property`)

通过查看这些定义，可以了解扩展支持哪些交互方式。

### 3. 运行时接口定义

运行时接口定义文件位于系统组件目录中：

- Python 扩展: `/app/agents/ten_packages/system/ten_runtime_python/interface`
- Go 扩展: `/app/agents/ten_packages/system/ten_runtime_go/interface`
- C++ 扩展: `/app/agents/ten_packages/system/ten_runtime_cpp/include`

这些文件定义了扩展可以使用的所有 API 函数和类型。

### 4. 示例代理的配置

查看示例代理的 `property.json` 文件，了解如何配置和连接不同的扩展：

- `/app/agents/examples/` 目录下的各种示例代理
- 特别是 `property.json` 中的 `predefined_graphs` 部分，展示了如何构建扩展节点图

### 5. 文档和注释

代码中的注释和可能存在的文档也是重要的参考来源：

- 函数和类的注释说明了它们的用途和参数
- 有些项目可能在 `/app/docs` 或类似目录下有更详细的文档

### 6. 框架核心代码

TEN 框架的核心代码也可以提供有关 API 设计和使用的深入信息：

- `/app/agents/ten_packages/system/` 目录下的系统组件
- 特别是运行时实现，展示了框架如何处理扩展的生命周期和通信

### 实际应用

在开发自己的扩展时，通常的做法是：

1. 找一个功能相似的现有扩展作为参考
2. 查看其 `manifest.json` 了解接口定义
3. 查看其实现代码了解 API 的具体使用方式
4. 参考运行时接口定义了解可用的所有 API
5. 根据需要修改和扩展功能


## 第三步：选择扩展类型并创建目录结构

### Python 扩展开发

1. **创建扩展目录**

```bash
# 在容器内执行
cd /app/agents/ten_packages/extension
mkdir my_python_extension
cd my_python_extension
```

2. **创建必要文件**

```bash
touch __init__.py
touch extension.py
touch manifest.json
touch property.json
```

3. **编写扩展代码 (extension.py)**

```python
from ten import Extension, TenEnv, Data, Cmd, CmdResult, StatusCode

class MyPythonExtension(Extension):
    def __init__(self, name: str):
        super().__init__(name)
        
    def on_init(self, ten: TenEnv) -> None:
        ten.log_info("MyPythonExtension initialized")
        ten.on_init_done()
        
    def on_start(self, ten: TenEnv) -> None:
        ten.log_info("MyPythonExtension started")
        
        # 读取配置属性示例
        greeting = ten.get_property_string("greeting")
        ten.log_info(f"Greeting property: {greeting}")
        
        # 发送一个示例数据
        output_data = Data.create("text_data")
        output_data.set_property_string("text", greeting)
        output_data.set_property_bool("end_of_segment", True)
        ten.send_data(output_data)
        
        ten.on_start_done()
        
    def on_data(self, ten: TenEnv, data: Data) -> None:
        # 处理接收到的数据
        if data.get_name() == "text_data":
            text = data.get_property_string("text")
            ten.log_info(f"Received text: {text}")
            
            # 处理文本并回复
            response = f"You said: {text}"
            output_data = Data.create("text_data")
            output_data.set_property_string("text", response)
            output_data.set_property_bool("end_of_segment", True)
            ten.send_data(output_data)
    
    def on_cmd(self, ten: TenEnv, cmd: Cmd) -> None:
        cmd_name = cmd.get_name()
        ten.log_info(f"Received command: {cmd_name}")
        
        # 处理命令
        if cmd_name == "hello":
            cmd_result = CmdResult.create(StatusCode.OK)
            cmd_result.set_property_string("message", "Hello from Python extension!")
            ten.return_result(cmd_result, cmd)
        else:
            cmd_result = CmdResult.create(StatusCode.ERROR)
            ten.return_result(cmd_result, cmd)
    
    def on_stop(self, ten: TenEnv) -> None:
        ten.log_info("MyPythonExtension stopped")
        ten.on_stop_done()
        
    def on_deinit(self, ten: TenEnv) -> None:
        ten.log_info("MyPythonExtension deinitialized")
        ten.on_deinit_done()

# 注册扩展
def register_extension(name: str) -> Extension:
    return MyPythonExtension(name)
```

4. **编写初始化文件 (__init__.py)**

```python
from . import extension

# 注册扩展
def register_extension(name):
    return extension.register_extension(name)
```

5. **创建 manifest.json**

```json
{
  "type": "extension",
  "name": "my_python_extension",
  "version": "0.1.0",
  "dependencies": [
    {
      "type": "system",
      "name": "ten_runtime_python",
      "version": "0.8"
    }
  ],
  "api": {
    "property": {
      "greeting": {
        "type": "string"
      }
    },
    "data_in": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "is_final": {
            "type": "bool"
          }
        }
      }
    ],
    "data_out": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "end_of_segment": {
            "type": "bool"
          }
        }
      }
    ],
    "cmd_in": [
      {
        "name": "hello"
      }
    ]
  }
}
```

6. **创建 property.json**

```json
{
  "greeting": "Hello from my Python extension!"
}
```

### Go 扩展开发

1. **创建扩展目录**

```bash
cd /app/agents/ten_packages/extension
mkdir my_go_extension
cd my_go_extension
```

2. **创建必要文件**

```bash
touch go.mod
touch extension.go
touch manifest.json
touch property.json
```

3. **编写 go.mod**

```
module my_go_extension

go 1.20

replace ten_framework => ../../system/ten_runtime_go/interface

require ten_framework v0.0.0-00010101000000-000000000000
```

4. **编写扩展代码 (extension.go)**

```go
package extension

import (
    "fmt"
    "ten_framework/ten"
)

const (
    textDataTextField = "text"
    textDataFinalField = "is_final"
    textDataEndOfSegmentField = "end_of_segment"
)

type myGoExtension struct {
    ten.DefaultExtension
}

func newExtension(name string) ten.Extension {
    return &myGoExtension{}
}

// OnStart 在扩展启动时调用
func (p *myGoExtension) OnStart(tenEnv ten.TenEnv) {
    tenEnv.LogInfo("MyGoExtension started")
    
    // 读取配置属性
    greeting, err := tenEnv.GetPropertyString("greeting")
    if err != nil {
        tenEnv.LogWarn(fmt.Sprintf("Failed to get greeting property: %v", err))
        greeting = "Default greeting"
    }
    
    // 发送一个示例数据
    data, _ := ten.NewData("text_data")
    data.SetPropertyString(textDataTextField, greeting)
    data.SetPropertyBool(textDataEndOfSegmentField, true)
    tenEnv.SendData(data)
    
    tenEnv.OnStartDone()
}

// OnData 处理接收到的数据
func (p *myGoExtension) OnData(tenEnv ten.TenEnv, data ten.Data) {
    text, err := data.GetPropertyString(textDataTextField)
    if err != nil {
        tenEnv.LogWarn(fmt.Sprintf("OnData GetProperty %s error: %v", textDataTextField, err))
        return
    }
    
    tenEnv.LogInfo(fmt.Sprintf("Received text: %s", text))
    
    // 处理文本并回复
    response := fmt.Sprintf("You said: %s", text)
    responseData, _ := ten.NewData("text_data")
    responseData.SetPropertyString(textDataTextField, response)
    responseData.SetPropertyBool(textDataEndOfSegmentField, true)
    tenEnv.SendData(responseData)
}

// OnCmd 处理接收到的命令
func (p *myGoExtension) OnCmd(tenEnv ten.TenEnv, cmd ten.Cmd) {
    cmdName := cmd.GetName()
    tenEnv.LogInfo(fmt.Sprintf("Received command: %s", cmdName))
    
    if cmdName == "hello" {
        cmdResult, _ := ten.NewCmdResult(ten.StatusCodeOK)
        cmdResult.SetPropertyString("message", "Hello from Go extension!")
        tenEnv.ReturnResult(cmdResult, cmd)
    } else {
        cmdResult, _ := ten.NewCmdResult(ten.StatusCodeError)
        tenEnv.ReturnResult(cmdResult, cmd)
    }
}

// OnStop 在扩展停止时调用
func (p *myGoExtension) OnStop(tenEnv ten.TenEnv) {
    tenEnv.LogInfo("MyGoExtension stopped")
    tenEnv.OnStopDone()
}

func init() {
    // 注册扩展
    ten.RegisterAddonAsExtension(
        "my_go_extension",
        ten.NewDefaultExtensionAddon(newExtension),
    )
}
```

5. **创建 manifest.json**

```json
{
  "type": "extension",
  "name": "my_go_extension",
  "version": "0.1.0",
  "dependencies": [
    {
      "type": "system",
      "name": "ten_runtime_go",
      "version": "0.8"
    }
  ],
  "api": {
    "property": {
      "greeting": {
        "type": "string"
      }
    },
    "data_in": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "is_final": {
            "type": "bool"
          }
        }
      }
    ],
    "data_out": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "end_of_segment": {
            "type": "bool"
          }
        }
      }
    ],
    "cmd_in": [
      {
        "name": "hello"
      }
    ]
  }
}
```

6. **创建 property.json**

```json
{
  "greeting": "Hello from my Go extension!"
}
```

### C++ 扩展开发

C++ 扩展开发相对复杂，需要更多的构建步骤：

1. **创建扩展目录**

```bash
cd /app/agents/ten_packages/extension
mkdir my_cpp_extension
cd my_cpp_extension
mkdir src
mkdir include
mkdir scripts
```

2. **创建必要文件**

```bash
touch src/extension.cpp
touch include/extension.h
touch scripts/BUILD.gn
touch manifest.json
touch property.json
```

3. **编写头文件 (include/extension.h)**

```cpp
#pragma once

#include "ten/extension.h"

namespace my_cpp_extension {

class MyCppExtension : public ten::Extension {
public:
    MyCppExtension(const std::string& name);
    ~MyCppExtension() override;

    // 扩展生命周期方法
    void OnInit(ten::TenEnv* ten_env) override;
    void OnStart(ten::TenEnv* ten_env) override;
    void OnData(ten::TenEnv* ten_env, ten::Data* data) override;
    void OnCmd(ten::TenEnv* ten_env, ten::Cmd* cmd) override;
    void OnStop(ten::TenEnv* ten_env) override;
    void OnDeinit(ten::TenEnv* ten_env) override;

private:
    std::string name_;
};

} // namespace my_cpp_extension
```

4. **编写实现文件 (src/extension.cpp)**

```cpp
#include "include/extension.h"
#include <iostream>

namespace my_cpp_extension {

MyCppExtension::MyCppExtension(const std::string& name) : name_(name) {}

MyCppExtension::~MyCppExtension() {}

void MyCppExtension::OnInit(ten::TenEnv* ten_env) {
    ten_env->LogInfo("MyCppExtension initialized");
    ten_env->OnInitDone();
}

void MyCppExtension::OnStart(ten::TenEnv* ten_env) {
    ten_env->LogInfo("MyCppExtension started");
    
    // 读取配置属性
    std::string greeting;
    ten_env->GetPropertyString("greeting", &greeting);
    ten_env->LogInfo("Greeting property: " + greeting);
    
    // 发送一个示例数据
    ten::Data* output_data = ten::Data::Create("text_data");
    output_data->SetPropertyString("text", greeting);
    output_data->SetPropertyBool("end_of_segment", true);
    ten_env->SendData(output_data);
    
    ten_env->OnStartDone();
}

void MyCppExtension::OnData(ten::TenEnv* ten_env, ten::Data* data) {
    if (data->GetName() == "text_data") {
        std::string text;
        data->GetPropertyString("text", &text);
        ten_env->LogInfo("Received text: " + text);
        
        // 处理文本并回复
        std::string response = "You said: " + text;
        ten::Data* output_data = ten::Data::Create("text_data");
        output_data->SetPropertyString("text", response);
        output_data->SetPropertyBool("end_of_segment", true);
        ten_env->SendData(output_data);
    }
}

void MyCppExtension::OnCmd(ten::TenEnv* ten_env, ten::Cmd* cmd) {
    std::string cmd_name = cmd->GetName();
    ten_env->LogInfo("Received command: " + cmd_name);
    
    if (cmd_name == "hello") {
        ten::CmdResult* cmd_result = ten::CmdResult::Create(ten::StatusCode::OK);
        cmd_result->SetPropertyString("message", "Hello from C++ extension!");
        ten_env->ReturnResult(cmd_result, cmd);
    } else {
        ten::CmdResult* cmd_result = ten::CmdResult::Create(ten::StatusCode::ERROR);
        ten_env->ReturnResult(cmd_result, cmd);
    }
}

void MyCppExtension::OnStop(ten::TenEnv* ten_env) {
    ten_env->LogInfo("MyCppExtension stopped");
    ten_env->OnStopDone();
}

void MyCppExtension::OnDeinit(ten::TenEnv* ten_env) {
    ten_env->LogInfo("MyCppExtension deinitialized");
    ten_env->OnDeinitDone();
}

// 创建扩展实例的工厂函数
extern "C" {
    ten::Extension* CreateExtension(const char* name) {
        return new my_cpp_extension::MyCppExtension(name);
    }
}

} // namespace my_cpp_extension
```

5. **创建构建文件 (scripts/BUILD.gn)**

```
# 构建C++扩展
shared_library("my_cpp_extension") {
  sources = [
    "src/extension.cpp",
  ]
  
  include_dirs = [
    ".",
    "//ten_packages/system/ten_runtime_cpp/include",
  ]
  
  deps = [
    "//ten_packages/system/ten_runtime_cpp:ten_runtime_cpp",
  ]
  
  output_dir = "lib"
}
```

6. **创建 manifest.json**

```json
{
  "type": "extension",
  "name": "my_cpp_extension",
  "version": "0.1.0",
  "dependencies": [
    {
      "type": "system",
      "name": "ten_runtime_cpp",
      "version": "0.8"
    }
  ],
  "api": {
    "property": {
      "greeting": {
        "type": "string"
      }
    },
    "data_in": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "is_final": {
            "type": "bool"
          }
        }
      }
    ],
    "data_out": [
      {
        "name": "text_data",
        "property": {
          "text": {
            "type": "string"
          },
          "end_of_segment": {
            "type": "bool"
          }
        }
      }
    ],
    "cmd_in": [
      {
        "name": "hello"
      }
    ]
  }
}
```

7. **创建 property.json**

```json
{
  "greeting": "Hello from my C++ extension!"
}
```

## 第三步：创建一个使用你的扩展的代理

1. **创建一个新的示例代理目录**

```bash
cd /app/agents/examples
mkdir my_custom_agent
cd my_custom_agent
```

2. **创建 property.json**

```json
{
  "_ten": {
    "predefined_graphs": [
      {
        "name": "my_custom_graph",
        "auto_start": true,
        "nodes": [
          {
            "type": "extension",
            "name": "my_extension",
            "addon": "my_python_extension",  // 或 "my_go_extension" 或 "my_cpp_extension"
            "extension_group": "default",
            "property": {
              "greeting": "Hello from my custom agent!"
            }
          }
          // 可以添加更多节点来构建更复杂的图
        ]
      }
    ]
  }
}
```

3. **创建 manifest.json**

```json
{
  "type": "app",
  "name": "my_custom_agent",
  "version": "0.1.0",
  "dependencies": [
    {
      "type": "system",
      "name": "ten_runtime_go",
      "version": "0.8"
    },
    {
      "type": "system",
      "name": "ten_runtime_python",
      "version": "0.8"
    },
    {
      "type": "extension",
      "name": "my_python_extension",
      "version": "0.1.0"
    }
  ]
}
```

## 第四步：构建和运行你的代理

```bash
# 回到容器的根目录
cd /app

# 使用你的自定义代理
task use AGENT=agents/examples/my_custom_agent

# 构建代理
task build

# 运行代理
task run
```

## 第五步：通过 Playground 测试你的扩展

1. 在浏览器中打开 [http://localhost:3000](http://localhost:3000)
2. 在 Playground 界面中，你应该能看到你的自定义代理和扩展
3. 你可以通过界面与你的扩展交互，发送文本或命令

## 调试技巧

1. **查看日志**：
   ```bash
   # 在容器内查看日志
   tail -f /var/log/ten-agent.log
   ```

2. **修改代码后重新构建**：
   ```bash
   # 修改代码后重新构建
   task build
   task run
   ```

3. **使用 Graph Designer 可视化编辑**：
   - 在 Playground 中，你可以使用图形界面编辑你的代理配置
   - 这样可以更直观地连接不同的扩展节点

## 总结

通过以上步骤，你已经学会了如何在 TEN 框架中创建 Python、Go 和 C++ 扩展，并将它们集成到一个自定义代理中。随着你对框架的熟悉，你可以创建更复杂的扩展和代理，实现更丰富的功能。

记住，TEN 框架的强大之处在于它能够让不同语言编写的扩展在同一个进程中协同工作，通过 Graph Designer 可视化编排，这使得构建复杂的 AI 代理变得更加简单和灵活。
